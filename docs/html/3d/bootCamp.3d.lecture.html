
<!DOCTYPE html>
<html>

<head>
	<title>Programming BootCamp Lecture: 3D Graphics</title>

	<!-- Header, 16th September, 2021 -->
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">

	<!-- Embedded fonts -->
	<link
			href="https://fonts.googleapis.com/css?family=Roboto|Roboto+Slab|Shadows+Into+Light|Source+Code+Pro&display=swap"
			rel="stylesheet">

	<!-- Custom layout and style -->
	<link rel="stylesheet" href="https://www.staff.city.ac.uk/~jwo/moodle/css/shCore.css" type="text/css" />
	<link rel="stylesheet" href="https://www.staff.city.ac.uk/~jwo/moodle/css/shThemeDefault.css" type="text/css" />
	<link rel="stylesheet" href="https://www.staff.city.ac.uk/~jwo/moodle/css/kube.min.css" type="text/css" />
	<link rel="stylesheet" href="https://www.staff.city.ac.uk/~jwo/moodle/css/master.css?rnd=123" type="text/css" />
	<link rel="stylesheet" href="https://www.staff.city.ac.uk/~jwo/moodle/css/highslide.css" type="text/css" />

	<!-- General browser compatibility handling -->
	<script type="text/javascript" src="https://www.staff.city.ac.uk/~jwo/moodle/js/jquery-3.1.0.slim.min.js"></script>

	<!-- Formatted source code -->
	<script type="text/javascript" src="https://www.staff.city.ac.uk/~jwo/moodle/js/shCore.js"></script>
	<script type="text/javascript" src="https://www.staff.city.ac.uk/~jwo/moodle/js/shBrushProcessing.js"></script>

	<!-- Sketch popups and hidden text-->
	<script src="https://www.staff.city.ac.uk/~jwo/moodle/js/highslide-with-html.packed.js"></script>
	<script src="https://www.staff.city.ac.uk/~jwo/moodle/js/highslide-cfg.js"></script>
	<script src="https://www.staff.city.ac.uk/~jwo/moodle/js/master.js"></script>

    <!-- iFrame -->
    <script type="text/javascript" src="https://jsndyks.github.io/cityBootCamp/js/iframeResizer.contentWindow.min.js"></script>
</head>

<body>
<div id="page">
        <!--
You can access [these Lecture Notes](https://jsndyks.github.io/cityBootCamp/html/3d/bootCamp.3d.lecture.html) outside of _Moodle_ should you wish to do so. 
		 -->

         <!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Introduction ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
	<!-- TITLE HEADING OF PAGE SHOULD BE VIA MOODLE, NOT HERE -->
	<!-- Add summary sentence or two below, which will act as an easy introduction -->

	<div class="intro">

		<p>
			In this session, you will learn how to program 3D graphics in Processing.
		</p>

		<p><strong>By the end of this session you should be able to:</strong></p>

		<ul>
			<li>Create sketches in Processing using the P3D renderer.</li>
			<li>Draw 3D objects using the built-in shapes as well as your own custom shapes.</li>
			<li>Use transformations to translate, rotate, and scale objects.</li>
			<li>Apply lighting and texture mapping.</li>
		</ul>

	</div> <!-- End of intro section -->
	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Main content ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->

	<div class="units-row">
		<div class="unit-70">
			<!-- Left column -->
			<h3>Motivation</h3>
			<p>
				So far all the graphics you have developed in the Coding BootCamp have been 2D graphics in
				Processing:
			<ul>
				<li>Built-in shapes: <code>ellipse</code>, <code>triangle</code>, <code>rect</code>, and more</li>
				<li>Programmer-defined shapes: <code>beginShape</code>, <code>vertex</code>, <code>endShape</code>
				</li>
				<li>Images</li>
			</ul>
			These techniques are very powerful, and can be used in countless ways to create engaging applications.
			<br />
			<img src="https://www.staff.city.ac.uk/~jwo/bootcamp2018/lecture12ThreeDee/images/apps.png" height="450"
				 alt="Example 2d sketches" />
			<br />
			But we live in a 3D world &mdash; you may be wondering, &quot;<i>Is it possible to do 3D graphics in
			Processing?</i>&quot; The answer is "<i>Yes</i>"!
			</p>

		</div> <!-- End of left column -->

		<div class="unit-30 annotation">
			<!-- Right column -->
			<!-- Empty -->
		</div> <!-- end of right column -->
	</div> <!-- End of row -->

	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->

	<div class="units-row">
		<div class="unit-70">
			<!-- Left column -->
			<h3>Going from 2D to 3D</h3>
			<p>
				Until now you have used 2D coordinates to describe a position (in pixels):
			<ul>
				<li><code>x</code> for horizontal</li>
				<li><code>y</code> for vertical</li>
			</ul>
			</p>
		</div> <!-- End of left column -->

		<div class="unit-30 annotation">
			<!-- Right column -->
			<img src="https://www.staff.city.ac.uk/~jwo/bootcamp2018/lecture12ThreeDee/images/xy.png" height="250"
				 alt="2D coordinate system">
			<p>
				The 2D coordinate system used in Processing.
			</p>

		</div> <!-- end of right column -->
	</div> <!-- End of row -->

	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->

	<div class="units-row">
		<div class="unit-70">
			<!-- Left column -->
			<p>
				In 3D space, a third axis is used to represent the <i>depth</i> of a point, to describe how far away
				the point is located. The 3D coordinate system used in Processing has
			<ul>
				<li><code>x</code> for horizontal</li>
				<li><code>y</code> for vertical</li>
				<li><code>z</code> for depth</li>
			</ul>
			Notice how the values along the z-axis become more negative as they move away from you and positive if
			they 'float' in front of the screen. The <b>origin</b> is the point in 3D space where the axes
			intersect. By definition it has coordinates (0, 0, 0) in 3D space. It is important you are
			comfortable with the idea of the origin as we will be using it extensively when thinking about
			transformation a little later in this session.
			</p>


		</div> <!-- End of left column -->

		<div class="unit-30 annotation">
			<!-- Right column -->
			<img src="https://www.staff.city.ac.uk/~jwo/bootcamp2018/lecture12ThreeDee/images/xyz.png" height="250"
				 alt="3D coordinates">
			<p>
				The 3D coordinate system used in Processing's P3D render mode.
			</p>
		</div> <!-- end of right column -->
	</div> <!-- End of row -->

	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->

	<div class="units-row">
		<div class="unit-70">
			<!-- Left column -->
			<h3>Processing render modes and OpenGL</h3>
			<p>
				Processing has several render modes, which can be set when the <code>size()</code> method is called
				in
				<code>setup()</code>. These are
			<ul>
				<li>The default renderer, providing 2D graphics (what you've used until now)</li>
				<li>The <code>P2D</code> renderer, providing 2D graphics using OpenGL</li>
				<li>The <code>FX2D</code> renderer &mdash; for 2D graphics with high quality output.</li>
				<li>The <code>PDF</code> renderer, used to create Adobe portable document vector graphics that can
					be scaled to any size</li>
				<li>The <code>P3D</code> renderer, providing 3D graphics using OpenGL</li>
			</ul>
			</p>

			<p>
				To program 3D graphics you <b>must use the <code>P3D</code> renderer</b> when setting up the sketch.
				This is easily achieved by passing in <code>P3D</code> as the third argument to <code>size()</code>,
				as shown below.
			</p>
			<pre class="brush: processing; gutter: false; toolbar: false; ">
void setup()
{
  size(640, 480, P3D);
}</pre>
			<p>
				This instructs Processing to create a sketch with a window capable of 3D graphics.
			</p>

		</div> <!-- End of left column -->

		<div class="unit-30 annotation">
			<!-- Right column -->
			<!-- Empty -->
		</div> <!-- end of right column -->
	</div> <!-- End of row -->

	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->

	<div class="units-row">
		<div class="unit-70">
			<!-- Left column -->
			<p>
				At this point, you may be wondering "What is OpenGL?" OpenGL stands for <i><b><i>Open</i></b>
				<b><i>G</i></b>raphics <b><i>L</i></b>ibrary</i>. It is a software interface to the graphics
				hardware. Many consumer electronic devices, including desktop computers, laptops, tablets, mobile
				phones, and satnav systems have dedicated graphics hardware to provide acceleration for 2D and 3D
				graphics. OpenGL is used in numerous applications, such as real-time computer games, computer-aided
				design (CAD) software, and much more.
			</p>

			<table>
				<tr>
					<td><img src="https://www.staff.city.ac.uk/~jwo/bootcamp2018/lecture12ThreeDee/images/minecraft.png"
							 height="250" alt="Minecraft"></td>
					<td><img src="https://www.staff.city.ac.uk/~jwo/bootcamp2018/lecture12ThreeDee/images/CAD.png"
							 height="250" alt="CAD software"></td>
					<td><img src="https://www.staff.city.ac.uk/~jwo/bootcamp2018/lecture12ThreeDee/images/googleEarth.png"
							 height="250" alt="Google Earth"></td>
				</tr>
				<tr>
					<td align="center">Minecraft</td>
					<td align="center">CAD software</td>
					<td align="center">Google Earth</td>
				</tr>
			</table>
			<p>
				For example, the applications above rely on OpenGL for accelerated 3D graphics.<br /><br />
			</p>

		</div> <!-- End of left column -->

		<div class="unit-30 annotation">
			<!-- Right column -->
			<!-- Empty -->
		</div> <!-- end of right column -->
	</div> <!-- End of row -->

	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->

	<div class="units-row">
		<div class="unit-70">
			<!-- Left column -->
			<h3>Built-in 3D shapes</h3>
			<p>
				Processing provides built-in 3D shapes you can use in your sketch. For example,
				<code>sphere()</code> takes one argument, the sphere radius, and draws a sphere centred at the
				origin (0,0,0). In the example below, a sphere with a radius of 200 is drawn. Note that the origin
				is translated (moved) to the centre of the window using a call to <code>translate()</code>. By
				moving the origin in this way, so the sphere centred on the new origin moves with it. This is a type
				of <i>transformation</i>, and will be discussed later in this session.
			</p>

		</div>
	</div>
	<div class="units-row">
		<div class="unit-70">
			<!-- Row break ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->

			<pre class="brush: processing; gutter: false; toolbar: false; ">
          void setup()
          {
            size(600, 500, P3D);
          }
          void draw()
          {
            background(0);
            translate(width/2, height/2, 0);
            sphere(200);

            noLoop();  // As sketch doesn't change, no need to repeat drawing loop.
          }</pre>


			<div class="task">
				If you were not to include the <code>translate</code> command in the sketch above, what do you think
				the output would look like? Try to answer this without running the sketch. Then confirm by
				commenting out the <code>translate</code> line and running the sketch.
			</div>


			<p>
				Processing makes writing 3d sketches easy by allowing the things you learned previously about
				colour, stroke, and fill to be applied to to 3D shapes too.
			</p>

			<div class="task">
				Which figure does the code below produce? A, B, C or D?
				<br /><br />

				<pre class="brush: processing; gutter: false; toolbar: false; ">
                void setup()
                {
                  size(600, 500, P3D);
                }
                void draw()
                {
                  background(0);
                  noFill();
                  stroke(255, 100, 100);
                  translate(width/2, height/2, 0);
                  sphere(200);
                  noLoop();
                }
            </pre>
				<table>
					<tr>
						<td><img src="https://www.staff.city.ac.uk/~jwo/bootcamp2018/lecture12ThreeDee/images/sphereA.png"
								 width="150" height="125" alt="Sphere A"></td>
						<td><img src="https://www.staff.city.ac.uk/~jwo/bootcamp2018/lecture12ThreeDee/images/sphereB.png"
								 width="150" height="125" alt="Sphere B"></td>
					</tr>
					<tr>
						<td><img src="https://www.staff.city.ac.uk/~jwo/bootcamp2018/lecture12ThreeDee/images/sphereC.png"
								 width="150" height="125" alt="Sphere C"></td>
						<td><img src="https://www.staff.city.ac.uk/~jwo/bootcamp2018/lecture12ThreeDee/images/sphereD.png"
								 width="150" height="125" alt="Sphere D"></td>
					</tr>
				</table>

				After making your guess, copy the code into Processing and run the sketch to see if you were
				correct. What effect does setting the fill and stroke colours have on the sphere? What happens when
				you set the fill colour to the same as the background?
			</div> <!-- End of task -->

		</div> <!-- End of left column -->

		<div class="unit-30 annotation">
			<!-- Right column -->
			<script>loadImage('https://www.staff.city.ac.uk/~jwo/bootcamp2018/lecture12ThreeDee/images/sphere.png', 600, 500, 'Simple sphere rendered in P3D');</script>
			<p>
				A sphere of radius 200 rendered to the sketch window.
			</p>
		</div> <!-- end of right column -->
	</div> <!-- End of row -->

	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->

	<div class="units-row">
		<div class="unit-70">
			<!-- Left column -->
			<p>
				Another built-in 3D shape is <code>box()</code>. If <code>box()</code> receives one parameter, it
				draws a cube. If <code>box</code> received three parameters, a box with different width, height, and
				depth is possible.
			</p>

			<table>
				<tr>
					<td align="center"><b>Cube</b></td>
					<td align="center"><b>Box</b></td>
				</tr>
				<tr>
					<td>
                            <pre class="brush: processing; gutter: false; toolbar: false; ">
translate(width/2, height/2, 0);
rotateX(radians(-30));
rotateY(radians(45));
box(200);</pre>
					</td>
					<td>
                            <pre class="brush: processing; gutter: false; toolbar: false; ">
translate(width/2, height/2, 0);
rotateX(radians(-30));
rotateY(radians(45));
box(200,150,100);</pre>
					</td>
				</tr>
			</table>

			<p>
				You will notice that in both box images to the right we are viewing the box as if slightly from
				above looking at one corner. This is achieved by rotating the coordinate system 45 degrees around
				the Y (vertical) axis and down 30 degrees around the X (horizontal) axis. This produces an effect as
				if we have moved an imaginary camera around the scene to point down at the box looking at one
				corner. To understand how to control this viewpoint, we need to understand a little more about
				<i>transformations</i>.
			</p>

		</div> <!-- End of left column -->

		<div class="unit-30 annotation">
			<!-- Right column -->
			<script>loadImage('https://www.staff.city.ac.uk/~jwo/bootcamp2018/lecture12ThreeDee/images/boxA.png', 600, 500, 'Simple cube of dimension 200');</script>
			<p>
				A simple box of dimensions 200 (width=200, height=200, depth=200).
			</p>

			<script>loadImage('https://www.staff.city.ac.uk/~jwo/bootcamp2018/lecture12ThreeDee/images/boxB.png', 600, 500, 'Simple box of dimensions (200,150,100)');</script>
			<p>
				A box of dimensions width=200, height=150, depth=100).
			</p>
		</div> <!-- end of right column -->
	</div> <!-- End of row -->

	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->

	<div class="units-row">
		<div class="unit-70">
			<!-- Left column -->

			<h3>3D Transformations</h3>
			<p>
				Being able to draw 3D shapes is great, but typically you will require a way of setting their
				position, orientation, and size. This is done using <i>transformations</i>. In Processing, there are
				three transformations (translation, rotation, and scaling) that are commonly used. To illustrate how
				they can be applied, we will draw a hand object centred at the origin of the 3D coordinate system:
				<br />
				<img src="https://www.staff.city.ac.uk/~jwo/bootcamp2018/lecture12ThreeDee/images/handOrigin.png"
					 width="400" height="400" alt="Untransformed hand" />
				<br />
				The key to understanding how transformations work is to appreciate that they apply to the
				<i>coordinate system</i> so that we do not have to explicitly change the values we use to position
				shapes on the screen.
			</p>

			<ol>
				<li><b>Translation</b> moves the origin of the coordinate system from one location to another. In
					Processing this is achieved using the method <code>translate(x, y, z)</code>, where
					<code>x</code>, <code>y</code>, and <code>z</code> are the amounts the origin should be moved
					along the x, y, and z axes respectively. For example, in the figure below, the coordinate system
					has been shifted 200 units along the x-axis, effectively moving the hand 200 units right (note
					that it is still being drawn around (0,0,0), but this new origin is now 200 units further right
					than its original position shown as grey lines). This shift can be achieved in Processing with
					the call <code>translate(200, 0, 0)</code>. The two 0 values indicate we are not shifting in the
					Y or Z directions.
					<br />
					<img src="https://www.staff.city.ac.uk/~jwo/bootcamp2018/lecture12ThreeDee/images/handTranslate.png"
						 width="800" height="500" alt="Translated hand" />
					<br />
					In a 3D Processing sketch, we often put <code>translate(width/2, height/2, 0);</code> as the
					first transformation in a <code>draw()</code> method. This shifts the origin of the coordinate
					system to the centre of the screen making it easier to position objects within the 3d
					scene.
					<br /><br />
				</li>

				<li><b>Rotation</b> rotates the coordinate system. Processing provides four methods to perform
					rotation, based on the axis of rotation.
					<ul>
						<li><code>rotateX(angle)</code> will rotate an object around the x-axis, by an angle given
							by <code>angle</code>.</li>
						<li><code>rotateY(angle)</code> will rotate an object around the y-axis, by an angle given
							by <code>angle</code>.</li>
						<li><code>rotateZ(angle)</code> will rotate an object around the z-axis, by an angle given
							by <code>angle</code>.</li>
						<li><code>rotate(angle, x, y, z)</code> will rotate an object around an axis pointing in the
							direction (x, y, z), by an angle given by <code>angle</code>.</li>
					</ul>
					<br />
					Positive angles represent a clockwise rotation around the axis when viewing the positive axis
					pointing towards you. For example, the following images rotate the coordinate system 40 degrees
					about the X, the Y and the Z axes respectively.
					<br />
					<img src="https://www.staff.city.ac.uk/~jwo/bootcamp2018/lecture12ThreeDee/images/handRotateX.png"
						 width="400" height="250" alt="Rotation around the X axis" />
					<br />
					<img src="https://www.staff.city.ac.uk/~jwo/bootcamp2018/lecture12ThreeDee/images/handRotateY.png"
						 width="400" height="250" alt="Rotation around the Y axis" />
					<br />
					<img src="https://www.staff.city.ac.uk/~jwo/bootcamp2018/lecture12ThreeDee/images/handRotateZ.png"
						 width="400" height="250" alt="Rotation around the Z axis" />
					<br />
					To rotate in an anti-clockwise direction, you can provide a negative rotation angle. The
					rotation angle is specified in <i>radians</i>, not degrees. Note that in Processing, you can
					convert from degrees to radians using the <code>radians()</code> method. For example,
					<code>rotateX(radians(-40));</code> would rotate the coordinate system 40 degrees anti-clockwise
					around the X-axis.
					<br /><br />
				</li>

				<li><b>Scaling</b> makes the coordinate system (and anything drawn in it) bigger or smaller. Scaling
					is done relative to the origin. When doing 3D graphics, there are two ways you can call the
					<code>scale()</code> method.
					<ul>
						<li>
							<code>scale(s)</code> will apply a uniform scaling to the coordinate system based on
							scaling factor <code>s</code>. A scaling factor of 1 does not change the size of
							anything. A scaling factor of 2, for example, will make everything twice as long along
							all axes (i.e. twice as wide, twice as tall and twice as deep, making the volume of any
							object eight times the size of the original). A scaling factor of 0.5 will make it half
							as big along all the axes.
							<br />
							<img src="https://www.staff.city.ac.uk/~jwo/bootcamp2018/lecture12ThreeDee/images/handScaleA.png"
								 width="400" height="250" alt="Scaling of 0.5 along all axes" />
						</li>
						<li>
							<code>scale(sx, sy, sz)</code> will apply separate scaling factors along the x, y, and z
							axes based on scaling factors <code>sx</code>, <code>sy</code>, and <code>sz</code>.
						</li>
						<br />
						<img src="https://www.staff.city.ac.uk/~jwo/bootcamp2018/lecture12ThreeDee/images/handScaleB.png"
							 width="400" height="250" alt="Scaling of 0.5 along all axes" />
					</ul>
				</li>
			</ol>


			<div class="task">
				Question: what kind of shape would you expect to see based on the following code?
				<br /><br />
				<pre class="brush: processing; gutter: false; toolbar: false; ">
scale(0.5, 1, 0.5);
sphere(100);</pre>
			</div>

			<br />
			<div class="tip">
				Just like <code>fill()</code> and <code>stroke()</code>, you should apply transformations
				<i>before</i> rendering the object. For example,
				<pre class="brush: processing; gutter: false; toolbar: false; ">
           translate(100, 0, 0);
           sphere(100);
        </pre>
				will translate the coordinate system and then render the sphere in the new coordinate space.
				However,
				<br /><br />
				<pre class="brush: processing; gutter: false; toolbar: false; ">
           sphere(100);
           translate(100, 0, 0);
        </pre>
				is likely to be a coding error since the sphere is rendered before the call to
				<code>translate</code> is made and therefore will not be affected by the change in coordinate space.
			</div>
			<br />
			<div class="codeTask">
				<h3>Animate a sphere</h3>
				Copy the code below into a Processing sketch and run it. You should see a red sphere rendered to the
				centre of the window. <b>Before</b> the call to <code>sphere()</code>, make a call to
				<code>rotateY()</code>. Base the rotation angle on the x-position of the mouse, i.e.
				<code>mouseX</code>. You may wish to convert <code>mouseX</code> to radians.
				<br /><br />
				<pre class="brush: processing; gutter: false; toolbar: false; ">
void setup()
{
  size(640, 480, P3D);
}

void draw()
{
  translate(width/2, height/2, 0);
  background(0);
  fill(255, 0, 0);
  sphere(100);
}</pre>
				Try rotating about a different axis, like the x or z axis. You could also try scaling the sphere.
			</div>

			<p>
				Note: Any transformations are cleared each time <code>draw()</code> is called. This means that
				although Processing may be calling <code>draw()</code> 60 times every second, the same set of
				transformations will be applied to the original coordinate system each time.
			</p>

			<div class="challenge">
				Create a sketch that rotates a sphere automatically without having to move the mouse.
			</div>
			<br /><br />
		</div> <!-- End of left column -->

		<div class="unit-30 annotation">
			<!-- Right column -->
			<!-- Do nothing -->
		</div> <!-- end of right column -->
	</div> <!-- End of row -->

	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->

	<div class="units-row">
		<div class="unit-70">
			<!-- Left column -->
			<h3>Composite transformations</h3>
			<p>
				Calls to <code>rotate()</code>, <code>translate()</code>, and <code>scale()</code> can be combined
				to form a <i>composite</i> transformation. When doing composite transformations, care must be taken,
				as in most cases <b>order matters</b>. For example, rotation, followed by translation, will give a
				different result than translation followed by rotation.
				<br /><br />
				<img src="https://www.staff.city.ac.uk/~jwo/bootcamp2018/lecture12ThreeDee/images/compositeA.png"
					 width="650" height="275" alt="Translation followed by rotation" />

				<br /><br />
				<img src="https://www.staff.city.ac.uk/~jwo/bootcamp2018/lecture12ThreeDee/images/compositeB.png"
					 width="650" height="275" alt="Rotation followed by translation" />
			</p>
			If you want an object to rotate about <b>its centre</b>, call the transformations in this order:
			<ul>
				<li><code>translate</code> origin to centre of object, <b>then</b></li>
				<li><code>rotate</code> object, <b>then</b> if you need to, </li>
				<li><code>scale</code></li>
			</ul>
			If instead you want an object to rotate about the <b>origin</b>, call the transformations in this order:
			<ul>
				<li><code>rotate</code> object, <b>then</b> if you need to,</li>
				<li><code>translate</code>, <b>then</b> if you need to,</li>
				<li><code>scale</code></li>
			</ul>
			<p>
				For example, the following code will produce an ellipsoid, rotating about its centre but shifted to
				the right.
			</p>


		</div>
	</div>
	<div class="units-row">
		<div class="unit-70">
			<!-- Row break ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->

			<pre class="brush: processing; gutter: false; toolbar: false; ">
float angle;

void setup()
{
  size(640, 480, P3D);
}

void draw()
{
  background(252,239,232);
  noFill();
  stroke(147,86,55);
  translate(width/2, height/2, 0);  // Centre the view.

  // Transform the coordinate space.
  translate(150, 0, 0);     // Shift it right
  rotateY(radians(angle));  // Rotate about its centre
  scale(1, 2, 1);           // Stretch it on along the y-axis

  sphere(100);              // Now draw after transformations.

  angle = angle + 1;        // Increase angle by 1 degree on every redraw.
}</pre>
			<div class="codeTask">
				Can you predict the effect of swapping the order of the lines <code>translate(150, 0, 0);</code> and
				<code>rotateY(radians(angle));</code> in the example above? Try editing the code to see if you are
				correct.
			</div>
		</div> <!-- End of left column -->

		<div class="unit-30 annotation">
			<!-- Right column -->
			<script>loadImage('https://www.staff.city.ac.uk/~jwo/bootcamp2018/lecture12ThreeDee/images/rotatingEllipsoid.png', 640, 480, 'Rotating ellipsoid');</script>
			<p>
				Rotating ellipsoid created by translating to the right, rotating and then scaling the Y-axis.
			</p>
		</div> <!-- end of right column -->
	</div> <!-- End of row -->

	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->

	<div class="units-row">
		<div class="unit-70">
			<!-- Left column -->
			<h3>Pushing and popping</h3>
			<p>
				Every time you do a rotation, translation, or scaling, the information required to do the
				transformation is composited into a single table of numbers. This table, or <i>matrix</i>, has only
				a few rows and columns, yet contains all the information needed to do any series of transformations.
				The matrix is applied to the coordinate space before rendering objects.
			</p>

			<p>
				If you're rending multiple 3D objects, it is common that you may wish to apply different
				transformations before rendering each of them. To do this efficiently, it is often useful to
				<i>push</i> and <i>pop</i> the transformation to and from a <i>stack</i>.
			<ul>
				<li><code>pushMatrix()</code> saves the current transformation.</li>
				<li><code>popMatrix()</code> restores the previously saved transformation.</li>
			</ul>
			</p>

			<p>
				To see how pushing and popping transformations can be used to transform two different objects,
				consider the following example that renders two spinning ellipsoids, each translated to different
				parts of the screen.
			</p>

		</div>
	</div>
	<div class="units-row">
		<div class="unit-70">
			<!-- Row break ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
			<pre class="brush: processing; gutter: false; toolbar: false; highlight:[16,21,24,29]">
float angle;

void setup()
{
  size(640, 480, P3D);
}

void draw()
{
  background(252,239,232);
  noFill();
  stroke(147,86,55);
  translate(width/2, height/2, 0);  // Centre the view.

  // Transform the first sphere to the right.
  pushMatrix();                // Store the current transformation settings.
    translate(150, 0, 0);      // Shift it right
    rotateY(radians(angle));   // Rotate about its centre
    scale(1, 2, 1);            // Stretch it on along the y-axis
    sphere(100);               // Draw the first sphere.
  popMatrix();                 // Restore the previous transformation settings.

  // Transform the second sphere to the left.
  pushMatrix();                // Store the current transformation settings.
    translate(-130, 0, 0);     // Shift it left
    rotateX(radians(angle));   // Rotate vertically about its centre
    scale(1, 2, 1);            // Stretch it on along the y-axis
    sphere(100);               // Draw the second sphere.
  popMatrix();                 // Restore the previous transformation settings.

  angle = angle + 1;           // Increase angle by 1 degree on every redraw.
}</pre>

			<div class="codeTask">
				What do you think would happen if you remove all the <code>pushMatrix()</code> and
				<code>popMatrix()</code> calls? Try copying the code above into a sketch and running it both with
				and without the pushing and popping to see if you are correct.
			</div>
		</div> <!-- End of left column -->

		<div class="unit-30 annotation">
			<!-- Right column -->
			<script>loadImage('https://www.staff.city.ac.uk/~jwo/bootcamp2018/lecture12ThreeDee/images/rotatingEllipsoids.png', 640, 480, 'Rotating ellipsoid');</script>
			<p>
				Two rotating ellipsoids each with their own transformations.
			</p>
		</div> <!-- end of right column -->
	</div> <!-- End of row -->

	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->

	<div class="units-row">
		<div class="unit-70">
			<!-- Left column -->
			<h3>Voxeliser</h3>
		</div>
	</div>
	<div class="units-row">
		<div class="unit-70">
			<!-- Row break ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
			<p>
				In an earlier session you learned about using images in Processing. This example reads colours from
				an image, and renders them as coloured cubes (also known as <i>voxels</i>) in 3D space. A colour
				<code>pixelColour</code> is taken from an image in a doubly-nested loop. The brightness of
				a pixel is determined using the <code>brightness()</code> method in Processing. This will range
				from 0 (darkest) to 255 (brightest). Voxels rotate with a speed based on <code>a</code>,
				and translate along the z axis based on <code>a</code> and the vertical position of the mouse.
				The code shows an example of using <code>pushMatrix</code> and <code>popMatrix</code> so that
				the transformation applied before drawing one voxel does not affect any other voxel.
			</p>

			<pre class="brush: processing; gutter: false; toolbar: false; ">
        PImage img;

        void setup()
        {
          size(500, 500, P3D);
          img = loadImage("https://gicentre.github.io/data/images/lovelace.jpg");
        }

        void draw()
        {
          background(255);
          int s = 8;    // Sample rate of pixels (s=8 -&gt; 1 in 8 pixels shown)

          // Centre view on image
          translate((width-img.width)/2,(height-img.height)/2,0);
          rotateY(radians(30));

          for (int y = 0; y &lt; img.height; y+= s)
          {
            for (int x = 0; x &lt; img.width; x+= s)
            {
              color pixelColour = img.get(x, y);
              fill(pixelColour);

              pushMatrix();
                float f = map(mouseY,0,height,-5,5);
                float a = brightness(pixelColour);
                translate(x, y, f*a);
                rotateY(a*radians(millis()/500.0));
                box((int) (s*0.75));
              popMatrix();
            }
          }
        }</pre>

		</div> <!-- End of left column -->

		<div class="unit-30 annotation">
			<!-- Right column -->
			<img src="https://gicentre.github.io/data/images/lovelace.jpg" height="450" alt="Input image">
			<p>Input image to the Voxeliser program.</p>

			<script>loadSketch("https://www.staff.city.ac.uk/~jwo/bootcamp2021/p5js/voxeliser", 482, 482, "https://www.staff.city.ac.uk/~jwo/bootcamp2018/lecture12ThreeDee/images/voxeliser.jpg");</script>
			<p>Voxeliser (click on image to activate).</p>
		</div> <!-- end of right column -->
	</div> <!-- End of row -->

	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->

	<div class="units-row">
		<div class="unit-70">
			<!-- Left column -->
			<h3>Other shapes</h3>
			<p>
				Although you can do a lot with spheres and boxes, Processing provides other ways to use shapes in
				3D. For example, the following methods can be used with 3D (x, y, z) coordinates:
			<ul>
				<li>
					<code><a href="https://processing.org/reference/point_.html" target="_new">point()</a></code>
				</li>
				<li>
					<code><a href="https://processing.org/reference/line_.html" target="_new">line()</a></code>
				</li>
				<li>
					<code><a href="https://processing.org/reference/curve_.html" target="_new">curve()</a></code>
				</li>
				<li>
					<code><a href="https://processing.org/reference/bezier_.html" target="_new">bezier()</a></code>
				</li>
				<li>
					<code><a href="https://processing.org/reference/text_.html" target="_new">text()</a></code>
				</li>
			</ul>
			</p>
			<p>
				You can use these methods in numerous ways to create 3D applications. As a simple example, the
				following program creates some text, and rotates it around the y axis. A call to
				<code>background()</code> in <code>draw()</code> isn't made so the graphics accumulate each time the
				text is rendered.
			</p>

		</div>
	</div>
	<div class="units-row">
		<div class="unit-70">
			<!-- Row break ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
			<pre class="brush: processing; gutter: false; toolbar: false; ">
void setup()
{
  size(640, 480, P3D);
  background(255);
}

void draw()
{
  textSize(32);
  fill(180, 25, 25, 50);
  translate(width/2, height/2);

  rotateY(-radians(millis()/10.0));
  text("City", 100, -80, 0);
  text("University", 100, 80, 0);
}
</pre>
			<p>
				Note this example does not use <code>pushMatrix()</code> and <code>popMatrix()</code>, so the
				rotation and translation is applied to both text objects that are each drawn to different positions
				on the screen.
			</p>

		</div> <!-- End of left column -->

		<div class="unit-30 annotation">
			<!-- Right column -->
			<script>loadImage('https://www.staff.city.ac.uk/~jwo/bootcamp2018/lecture12ThreeDee/images/rotatedText.png', 640, 480, 'Rotating text');</script>
			<p>Rotating text.</p>
		</div> <!-- end of right column -->
	</div> <!-- End of row -->

	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->

	<div class="units-row">
		<div class="unit-70">
			<!-- Left column -->

			<h3>Making your own 3D shapes</h3>

			<p>
				You can make your own 3D shapes too. This can be achieved by calling <code>beginShape()</code>,
				specifying 3D vertices, followed by a call to <code>endShape()</code>. The method
				<code>beginShape()</code> takes a single optional parameter, the type of shape. Common shape types
				are <code>TRIANGLES</code> for triangles (three sided polygons), or <code>QUADS</code> for
				quadrilaterals (four sided polygons). If no shape type is provided, Processing assumes the shape is
				a general polygon. Then, you can provide a set of 3D vertices. Processing will group the vertices
				based on the shape type. For example, if the shape type is <code>TRIANGLES</code>, Processing will
				group every three vertices to form a triangle. Finally, when you are done specifying vertices, you
				call <code>endShape()</code>. An example of forming a tetrahedron (four sided pyramid) composed of
				four triangles is given below.
			</p>

		</div>
	</div>
	<div class="units-row">
		<div class="unit-70">
			<!-- Row break ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
			<pre class="brush: processing; gutter: false; toolbar: false; ">
void setup()
{
  size(600,500,P3D);
}

void draw()
{
  background(0);
  fill(255);
  translate(width/2, height/2, 190);

  rotateX(radians(-mouseY-height/2));
  rotateY(radians(mouseX-width/2));

  beginShape(TRIANGLES);

    vertex(0, 0, 100);
    vertex(-100, 100, 0);
    vertex(100, 100, 0);

    vertex(0, 0, 100);
    vertex(100, 100, 0);
    vertex(0, -100, 0);

    vertex(0, 0, 100);
    vertex(0, -100, 0);
    vertex(-100, 100, 0);

    vertex(-100, 100, 0);
    vertex(100, 100, 0);
    vertex(0, -100, 0);

  endShape();
}</pre>

		</div> <!-- End of left column -->

		<div class="unit-30 annotation">
			<!-- Right column -->
			<script>loadImage('https://www.staff.city.ac.uk/~jwo/bootcamp2018/lecture12ThreeDee/images/tetrahedron.png', 600, 500, 'Tetrahedron as a custom shape');</script>
			<p>
				A tetrahedron as a custom shape made up of triangles.
			</p>


		</div> <!-- end of right column -->
	</div> <!-- End of row -->

	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->

	<div class="units-row">
		<div class="unit-70">
			<!-- Left column -->

			<p>
				You can set the colours of the the shape with <code>fill()</code> and <code>stroke()</code>
				just like you can with 2d shapes, but additionally you can set the colours of individual
				vertices of a 3d shape and Processing will <i>interpolate</i> between the colours
				at each vertex.
			</p>

			<p>
				Here's a modification of the tetrahedron with the addition of red and blue fill colours
				around the vertices. Note how, just like a 2d sketch, once a colour is set, that colour
				will be used until another colour is set later on in the draw loop.
			</p>


		</div>
	</div>
	<div class="units-row">
		<div class="unit-70">
			<!-- Row break ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
			<pre class="brush: processing; gutter: false; toolbar: false; ">
          void setup()
          {
            size(600,500,P3D);
          }

          void draw()
          {
            background(0);
            translate(width/2, height/2, 190);

            rotateX(radians(-mouseY-height/2));
            rotateY(radians(mouseX-width/2));

            beginShape(TRIANGLES);

              fill(255,0,0);
              vertex(0, 0, 100);
              fill(0,0,255);
              vertex(-100, 100, 0);
              vertex(100, 100, 0);

              fill(255,0,0);
              vertex(0, 0, 100);
              fill(0,0,255);
              vertex(100, 100, 0);
              vertex(0, -100, 0);

              fill(255,0,0);
              vertex(0, 0, 100);
              fill(0,0,255);
              vertex(0, -100, 0);
              vertex(-100, 100, 0);

              vertex(-100, 100, 0);
              vertex(100, 100, 0);
              vertex(0, -100, 0);

            endShape();
          }</pre>

		</div> <!-- End of left column -->

		<div class="unit-30 annotation">
			<!-- Right column -->
			<script>loadImage('https://www.staff.city.ac.uk/~jwo/bootcamp2018/lecture12ThreeDee/images/tetrahedronColoured.png', 600, 500, 'Tetrahedron with coloured vertices');</script>
			<p>
				A tetrahedron with coloured vertices.
			</p>


		</div> <!-- end of right column -->
	</div> <!-- End of row -->

	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->

	<div class="units-row">
		<div class="unit-70">
			<!-- Left column -->

			<h3>Even more shapes</h3>
			<p>
				For more complex shapes, the
				<code><a href="https://processing.org/reference/PShape.html" target="_blank">PShape</a></code> class
				can be used to load OBJ files. An OBJ file uses a standard text format to represent complex geometry
				such as buildings, people, cars etc. For example the <a
					href="https://www.turbosquid.com/Search/3D-Models/free/hand" target="_blank">hand.obj</a> file
				was used to show the transformed hands above and can be loaded and displayed in Processing as
				follows:
			</p>
		</div>
	</div>
	<div class="units-row">
		<div class="unit-70">
			<!-- Row break ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
			<pre class="brush: processing; gutter: false; toolbar: false; ">PShape hand;    // Stores the complex geometry.

public void setup()
{
  size(500, 500, P3D);
  hand = loadShape("Hand.obj");    // Load .obj file.
}

public void draw()
{
  background(255);
  lights();

  // Viewing transformation.
  translate(width/2, height/2, 180);

  // Draws the .obj feature.
  shape(hand);
}</pre>

			<p>
				If you would like to run the sketch above, make sure you drag the <a
					href="https://gicentre.github.io/data/object3d/Hand.obj" target="_blank">hand.obj</a> file into
				your sketch before running it.
			</p>

		</div> <!-- End of left column -->

		<div class="unit-30 annotation">
			<!-- Right column -->
			<script>loadImage('https://www.staff.city.ac.uk/~jwo/bootcamp2018/lecture12ThreeDee/images/hand.png', 400, 400, 'Hand.obj file rendered as a PShape');</script>
			<p>
				Hand .obj file rendered as a PShape.
			</p>


		</div> <!-- end of right column -->
	</div> <!-- End of row -->

	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->

	<div class="units-row">
		<div class="unit-70">
			<!-- Left column -->
			<h3>Shading</h3>
			<p>
				You may have wondered where the shadows on the hand above have come from. They are not stored
				directly in the .obj file, but rather they are calculated in Processing based on the geometry of the
				3d surface and the lighting conditions you set in your sketch.
			</p>

			<p>
				The P3D renderer allows manipulation of the lights and materials in the scene. These are used to
				convey <i>shading</i>, that is, gradations in colour that provide an illusion of depth. Lighting
				refers to the light sources that are illuminating the objects. Just like in the real world, a light
				source may have properties, like a position and colour. However, the colour one observes for a
				surface depends not only on the properties of the lights but also the material, which describes how
				the light reflects off the surface.
			</p>

			<p>
				Processing can make this very simple, however. To turn the default lighting (and materials) on,
				simply call <code>lights()</code> in the <code>draw()</code> method of your sketch. One line of code
				&ndash; how easy is that?!
			</p>

			<p>
				Notice how the three dimensional shape of the sphere is not apparent until lighting is enabled.
			</p>

			<p>
				In many cases the default lighting and materials will be sufficient for your scene. However,
				Processing makes it possible for you to control these more precisely. There are four different types
				of lights (ambient, directional, point light, and spotlight), each with parameters like the light
				colour. In addition, there are five different material properties (ambient, diffuse, specular,
				emissive) reflectance as well as the shininess. Covering all these different properties and
				combinations is beyond the scope of this session so we'll just touch on a couple of them &mdash;
				directional light and specular reflectance. But do feel free to experiment with the other lighting
				and surface materials.
			</p>

			<p>
				A <b>directional light</b> is a light source that has no position, only a direction. This is a
				useful to model a light source that is far away such as the sun. The light rays that reach a surface
				can be considered parallel. In Processing, we can include a directional light in the scene by
				calling the <code>directionalLight(r, g, b, x, y, z)</code> method. The <code>r</code>,
				<code>g</code>, and <code>b</code> parameters give the light source colour, and the <code>x</code>,
				<code>y</code>, <code>z</code> parameters give the direction the light is going.
			</p>

		</div> <!-- End of left column -->

		<div class="unit-30 annotation">
			<!-- Right column -->
			<script>loadImage('https://www.staff.city.ac.uk/~jwo/bootcamp2018/lecture12ThreeDee/images/lightSphere1.png', 400, 400, 'Red sphere with lights off');</script>
			<p>
				Red sphere with lights off.
			</p>
			<script>loadImage('https://www.staff.city.ac.uk/~jwo/bootcamp2018/lecture12ThreeDee/images/lightSphere2.png', 400, 400, 'Red sphere with lights on');</script>
			<p>
				Red sphere with lights on.
			</p>


		</div> <!-- end of right column -->
	</div> <!-- End of row -->

	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->

	<div class="units-row">
		<div class="unit-70">
			<!-- Left column -->
			<p>
				The diffuse colour of the surface is given by the <code>fill</code> colour. You can think of this as
				the main colour of the object. However, in the real world, some objects exhibit <b>specular
				reflection</b>, where the light source of the scene is reflected off the surface. Consider the
				apple shown to the right; the white light is reflected off the surface, creating a specular
				highlight that appears white, even though the apple is red.
			</p>

			<p>
				In Processing we can produce such an effect using by including a specular component to the light and
				material. The method <code>lightSpecular(r, g, b)</code> will include a specular colour (given by
				<code>r</code>, <code>g</code>, <code>b</code>) to the light source. We can control how this
				specular light is reflected off the surface by calling the method <code>specular(r,g,b)</code>,
				where <code>r</code>, <code>g</code>, <code>b</code> describe the amount of light reflected in the
				red, green, and blue channels. Finally, the shininess controls the size of specular highlight,
				describing how glossy the surface appears. Objects that are very shiny have small, focussed specular
				highlights. In Processing, the method <code>shininess(shine)</code> is used to control this level of
				gloss, and the <code>shine</code> parameter ranges from 0 to 255.
			</p>

		</div> <!-- End of left column -->

		<div class="unit-30 annotation">
			<!-- Right column -->
			<script>loadImage('https://www.staff.city.ac.uk/~jwo/bootcamp2018/lecture12ThreeDee/images/Apple.png', 291, 255, 'Specular reflection');</script>
			<p>A surface with a specular highlight</p>
		</div> <!-- end of right column -->
	</div> <!-- End of row -->

	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->

	<div class="units-row">
		<div class="unit-70">
			<!-- Left column -->
			<p>
				The following Processing sketch shows the effect of adding specular highlights and directional light
				to a scene.
			</p>
		</div>
	</div>
	<div class="units-row">
		<div class="unit-70">
			<!-- Row break ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
			<pre class="brush: processing; gutter: false; toolbar: false; ">int option;

void setup()
{
  size(400,400, P3D);
  noStroke();
  fill(255, 0, 0);
}

void draw()
{
  background(255);

  if (option == 1)
  {
     lights();		// Lights on
  }
  else if (option == 2)
  {
     // Custom lighting
     lightSpecular(200, 200, 200);
     specular(255, 255, 255);
     shininess(25);
     float hw = width /2;
     float hh = height /2;
     directionalLight(255, 255, 255, -(mouseX-hw)/hw, -(mouseY-hh)/hh, -1);
  }
  translate(width/2, height/2, 0);
  sphere(150);
}
void mouseClicked()
{
  option++;
  if (option &gt; 2)
  {
    option = 0;
  }
}</pre>
		</div> <!-- End of left column -->

		<div class="unit-30 annotation">
			<!-- Right column -->
			<script>loadSketch("https://www.staff.city.ac.uk/~jwo/bootcamp2021/p5js/ballLight", 400, 400, "https://www.staff.city.ac.uk/~jwo/bootcamp2018/lecture12ThreeDee/images/lightSphere3.png");</script>
			<p>Lights (click on image to activate, then click again on the image to cycle between options).</p>
		</div> <!-- end of right column -->
	</div> <!-- End of row -->

	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->

	<div class="units-row">
		<div class="unit-70">
			<!-- Left column -->
			<h3>Texture mapping</h3>
			<p>
				In many cases, rendering a shape with a single colour is sufficient, but sometimes you might want to
				apply an image instead. In <i>texture mapping</i>, you can transfer colours from an image (also
				known as a <i>texture</i>) onto the surface, composed of polygons.
			</p>
			<img src="https://www.staff.city.ac.uk/~jwo/bootcamp2018/lecture12ThreeDee/images/TextureMapping.png"
				 height="250" alt="Texture mapping" />

		</div>
	</div>
	<div class="units-row">
		<div class="unit-70">
			<!-- Row break ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
			<p>
				A convenient way to think about texture mapping is that it is similar to wall papering. You have a
				2D image (wallpaper) that you'd like to cut out and paste onto a 3D surface (the wall). In texture
				mapping, you use <i>texture coordinates</i> to select the portion of the image to be transferred to
				the surface. In Processing, you refer to texture coordinates as <i>uv</i> coordinates, as they
				describe a 2D coordinate system of the image that describe two axes at right angles, just as normal
				geometric axes are labelled x- and y-axes. Normally, texture coordinates are normalised so that the
				u and v coordinates range between 0 and 1.
			</p>
		</div> <!-- End of left column -->

		<div class="unit-30 annotation">
			<!-- Right column -->
			<script>loadImage('https://www.staff.city.ac.uk/~jwo/bootcamp2018/lecture12ThreeDee/images/uv.png', 476, 355, 'Texture coordinates');</script>
			<p>Texture coordinates (u, v).</p>
		</div> <!-- end of right column -->
	</div> <!-- End of row -->

	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->

	<div class="units-row">
		<div class="unit-70">
			<!-- Left column -->
			<p>
				Specifying texture coordinates depends on the application. For example, if you're texture mapping a
				cube, it may be natural to have a complete copy of the image on each side of the cube. In this case,
				each quad forming a side of the cube would have texture coordinates span the entire image. An
				example is shown below. Indeed, in Processing, if you look at the TextureCube
				(File-&gt;Topics-&gt;Textures-&gt;TextureCube) example, it textures each side of the cube like this.
			</p>
		</div> <!-- End of left column -->

		<div class="unit-30 annotation">
			<!-- Right column -->
			<script>loadImage('https://www.staff.city.ac.uk/~jwo/bootcamp2018/lecture12ThreeDee/images/TextureQuad.png', 664, 667, 'Texture coordinates for a quad');</script>
			<p>Texture coordinates for a quad.</p>
		</div> <!-- end of right column -->
	</div> <!-- End of row -->

	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->

	<div class="units-row">
		<div class="unit-70">
			<!-- Left column -->
			<p>
				To do texture mapping, you'll require an image. This can be loaded with the standard
				<code>loadImage()</code> command. Texture coordinates are provided using the
				<code>vertex(x, y, z, u, v)</code> command. Each vertex has a position in xyz space, and a texture
				coordinate in uv space. In addition, you must call <code>texture()</code> to let Processing know
				which image you intend to use when texture mapping. The code below provides an example of doing
				texture mapping by creating a regular mesh with equally spaced vertices in x and y. However, the z
				value of each vertex is based on <i>Perlin noise</i>. The calls to <code>vertex()</code> include
				texture coordinates that span values between 0 and 1, transferring a single copy of the image onto
				the surface. Since the underlying geometry is changing, it distorts the appearance of the image on
				the surface. Funhouse effect!
			</p>

			<h3>Distorto</h3>

		</div>
	</div>
	<div class="units-row">
		<div class="unit-70">
			<!-- Row break ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
			<pre class="brush: processing; gutter: false; toolbar: false; ">PImage image;

void setup()
{
  size(640, 480, P3D);
  image = loadImage("lovelace.jpg");
}

void draw()
{
  background(255);
  stroke(255);
  translate(width/2, height/2, -200);

  rotateX(radians(mouseY));
  int  d = 16;                 // spacing of vertices
  float s = 0.003;
  float t = millis() / 5000.0; // Deformation rate
  float w = width;
  float h = height;

  for (int x = 0; x &lt; width; x += d)
  {
    for(int y = 0; y &lt; height; y += d)
    {
      float z1 = (noise(x*s,y*s,t) - 0.5) * w;
      float z2 = (noise((x+d)*s,y*s,t) - 0.5) * w;
      float z3 = (noise((x+d)*s,(y+d)*s,t) - 0.5) * w;
      float z4 = (noise(x*s,(y+d)*s,t) - 0.5) * w;

      beginShape(QUADS);
        textureMode(NORMAL);
        texture(image);
        vertex(x-w/2,   y-h/2,   z1, x/w,      y/h);
        vertex(x+d-w/2, y-h/2,   z2, (x+d)/w,  y/h);
        vertex(x+d-w/2, y+d-h/2, z3, (x+d)/w, (y+d)/h);
        vertex(x-w/2,   y+d-h/2, z4, x/w,     (y+d)/h);
      endShape();
    }
  }
}</pre>
		</div> <!-- End of left column -->

		<div class="unit-30 annotation">
			<!-- Right column -->
			<script>loadSketch("https://www.staff.city.ac.uk/~jwo/bootcamp2021/p5js/distorto", 640, 640, "https://www.staff.city.ac.uk/~jwo/bootcamp2018/lecture12ThreeDee/images/distorto.png");</script>

			<p>Distorto texture maps a surface, and uses Perlin noise to distort the surface geometry (click to
				activate).</p>
		</div> <!-- end of right column -->
	</div> <!-- End of row -->

	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->

	<div class="units-row">
		<div class="unit-70">
			<!-- Left column -->
			<h3>Summary and Further Reading</h3>
			<ul>
				<li>You can program 3D computer graphics in Processing using the <code>P3D</code> renderer. 3D
					graphics includes another dimension <code>z</code> representing depth.</li>
				<li>The <code>P3D</code>renderer uses OpenGL for accelerated graphics.</li>
				<li>There are many ways to make 3D shapes, including using built-in shapes like <code>box</code> or
					<code>sphere</code> and making your own custom shapes with vertices.
				</li>
				<li>3D transformations are commonly used to translate, rotate, and/or scale an object in 3D space.
				</li>
				<li>Advanced effects like lighting and texture mapping are supported in Processing, and can be used
					to create interesting effects and applications.</li>
				<li>The Processing website has a good tutorial on 3D graphics: <a
						href="https://processing.org/tutorials/p3d/" target="_blank">
					https://processing.org/tutorials/p3d/</a></li>
			</ul>
		</div> <!-- End of left column -->
	</div> <!-- End of row -->

        <!--- spacer for iFrame -->
        <p style="padding-top:1em"><hr/></p>

	<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Footer ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
</div> <!-- End of page div -->
<script type="text/javascript">SyntaxHighlighter.all()</script>
</body>

</html>